# Cursor Rules for local-ai-packaged

## Sample Files

- **Sample files should be created in the `sample/` directory**
- Sample capability tests and demonstrations should go in `sample/capability/`
- Sample files are for testing, demonstration, and learning purposes
- Keep sample files self-contained and well-documented

## Code Style

- Follow the patterns established in `AGENTS.md`
- Use Python 3.10+ features
- Follow Black formatting (line-length: 100)
- Use Ruff for linting (target: py310)

## Project Structure

- See `AGENTS.md` for detailed project structure and conventions
- Stack-based Docker Compose architecture
- Monorepo with numbered stacks (00-infrastructure, 01-data, etc.)

## Exception Handling

- **Prefer loud errors over silent failures**: We would rather have code error loudly (fail fast) than hide errors by catching raw exceptions. This makes debugging easier and ensures issues are discovered immediately.
- **NEVER use naked exceptions** (bare `except:` clauses). Always catch specific exception types.
- **Avoid catching `Exception`**: Do not use `except Exception as e:` unless absolutely necessary. Instead, let exceptions bubble up naturally so they can be properly handled at the appropriate level or logged by the framework.
- **Use the structured exception layer** informed by service and capability:
  - Base exception: `BaseProjectException` from `server.core.exceptions`
  - Service-specific exceptions: `MongoDBException`, `LLMException`, `ConfigurationException`, etc.
  - Domain-specific exceptions: `ValidationException`, `NotFoundException`
- **When to create new exception types**:
  - Create service-specific exceptions (e.g., `SupabaseException`, `Neo4jException`) that inherit from `BaseProjectException`
  - Create capability-specific exceptions (e.g., `WorkflowException`, `RAGException`) for domain logic
  - Include relevant context (operation, resource, model, etc.) in exception initialization
- **Exception handling pattern**:
  - Use `@handle_project_errors()` decorator for API endpoints (see `server.core.error_handling`)
  - Catch specific exceptions only when you can meaningfully handle them (e.g., retry logic, fallback behavior)
  - Let unexpected exceptions propagate to be handled by framework-level error handlers
  - If you must catch a broad exception, ensure it's logged and re-raised, not silently swallowed
