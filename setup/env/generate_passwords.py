#!/usr/bin/env python3
"""
Generate XKCD-style passphrases for .env file setup.

This script generates secure, memorable passphrases using common words,
following the XKCD password strength methodology.
"""

import random
import secrets
import sys
from pathlib import Path

# EFF Large Word List (simplified - common words)
# Full list available at: https://www.eff.org/files/2016/07/18/eff_large_wordlist.txt
WORD_LIST = [
    # Common nouns
    "apple", "book", "car", "dog", "house", "tree", "water", "fire", "earth", "wind",
    "moon", "star", "sun", "ocean", "mountain", "river", "forest", "valley", "cloud",
    "bird", "fish", "cat", "horse", "cow", "sheep", "chicken", "duck", "goose",
    "table", "chair", "door", "window", "wall", "floor", "roof", "room", "bed",
    "paper", "pen", "pencil", "computer", "phone", "key", "lock", "box", "bag",
    
    # Verbs
    "run", "walk", "jump", "fly", "swim", "dance", "sing", "play", "work", "sleep",
    "eat", "drink", "cook", "read", "write", "draw", "paint", "build", "create",
    "think", "learn", "teach", "help", "give", "take", "make", "do", "go", "come",
    "see", "hear", "feel", "touch", "smell", "taste", "know", "understand", "remember",
    
    # Adjectives
    "big", "small", "hot", "cold", "fast", "slow", "high", "low", "long", "short",
    "good", "bad", "new", "old", "young", "old", "happy", "sad", "angry", "calm",
    "bright", "dark", "light", "heavy", "soft", "hard", "smooth", "rough", "clean",
    "dirty", "wet", "dry", "warm", "cool", "quiet", "loud", "sweet", "sour", "bitter",
    
    # Additional common words
    "time", "day", "night", "morning", "evening", "week", "month", "year", "hour",
    "minute", "second", "today", "tomorrow", "yesterday", "now", "then", "here", "there",
    "up", "down", "left", "right", "front", "back", "inside", "outside", "near", "far",
    "red", "blue", "green", "yellow", "orange", "purple", "pink", "brown", "black", "white",
    "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten",
]

def generate_passphrase(num_words=4, separator="-"):
    """
    Generate an XKCD-style passphrase.
    
    Args:
        num_words: Number of words in the passphrase (default: 4)
        separator: Character to separate words (default: "-")
    
    Returns:
        A passphrase string
    """
    words = [secrets.choice(WORD_LIST) for _ in range(num_words)]
    return separator.join(words)


def generate_hex_string(length=32):
    """
    Generate a random hexadecimal string.
    
    Args:
        length: Length of hex string in characters (default: 32)
    
    Returns:
        A hexadecimal string
    """
    return secrets.token_hex(length // 2)


def generate_base64_string(length=32):
    """
    Generate a random base64 string.
    
    Args:
        length: Length of base64 string in bytes (default: 32)
    
    Returns:
        A base64-encoded string
    """
    import base64
    return base64.b64encode(secrets.token_bytes(length)).decode('utf-8')


def generate_uuid():
    """Generate a UUID string."""
    import uuid
    return str(uuid.uuid4())


def main():
    """Generate passwords for .env file."""
    print("=" * 60)
    print("  Environment File Password Generator")
    print("  Using XKCD-style passphrases for security and memorability")
    print("=" * 60)
    print()
    
    # Configuration
    passphrase_words = 4  # Number of words in passphrases
    hex_length = 32  # Length for hex strings
    
    print("Generated passwords for .env file:")
    print("-" * 60)
    print()
    
    # N8N Configuration
    print("# N8N Configuration")
    print(f"N8N_ENCRYPTION_KEY={generate_hex_string(hex_length)}")
    print(f"N8N_USER_MANAGEMENT_JWT_SECRET={generate_hex_string(hex_length)}")
    print()
    
    # Supabase Secrets
    print("# Supabase Secrets")
    print(f"POSTGRES_PASSWORD={generate_passphrase(passphrase_words)}")
    print(f"JWT_SECRET={generate_hex_string(hex_length)}")
    print("# ANON_KEY and SERVICE_ROLE_KEY are generated by Supabase setup")
    print("ANON_KEY=")
    print("SERVICE_ROLE_KEY=")
    print(f"DASHBOARD_USERNAME=admin")
    print(f"DASHBOARD_PASSWORD={generate_passphrase(passphrase_words)}")
    print(f"POOLER_TENANT_ID={generate_uuid()}")
    print()
    
    # Neo4j Secrets
    print("# Neo4j Secrets")
    print(f"NEO4J_AUTH=neo4j/{generate_passphrase(passphrase_words)}")
    print()
    
    # MongoDB Secrets
    print("# MongoDB Secrets")
    print("MONGODB_ROOT_USERNAME=admin")
    print(f"MONGODB_ROOT_PASSWORD={generate_passphrase(passphrase_words)}")
    print("MONGODB_DATABASE=admin")
    print()
    
    # Langfuse Credentials
    print("# Langfuse Credentials")
    print(f"CLICKHOUSE_PASSWORD={generate_passphrase(passphrase_words)}")
    print(f"MINIO_ROOT_PASSWORD={generate_passphrase(passphrase_words)}")
    print(f"LANGFUSE_SALT={generate_hex_string(hex_length)}")
    print(f"NEXTAUTH_SECRET={generate_hex_string(hex_length)}")
    print(f"ENCRYPTION_KEY={generate_hex_string(hex_length)}")
    print()
    
    # Infisical Configuration
    print("# Infisical Configuration")
    print(f"INFISICAL_ENCRYPTION_KEY={generate_hex_string(16)}")
    print(f"INFISICAL_AUTH_SECRET={generate_base64_string(32)}")
    print("INFISICAL_HOSTNAME=:8010")
    print("INFISICAL_SITE_URL=http://localhost:8010")
    print()
    
    print("-" * 60)
    print()
    print("Instructions:")
    print("1. Copy the values above to your .env file")
    print("2. Generate ANON_KEY and SERVICE_ROLE_KEY using Supabase setup")
    print("3. Add your Docker Hub credentials")
    print("4. Configure hostnames for your domain (if using Cloudflare)")
    print()
    print("Security Notes:")
    print("- These passwords are generated using cryptographically secure random number generation")
    print("- XKCD passphrases are easier to remember than random strings")
    print("- Store sensitive secrets in Infisical, not in .env file")
    print("- Never commit .env file to version control")
    print()


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\nGeneration cancelled.")
        sys.exit(1)
    except Exception as e:
        print(f"\nError: {e}", file=sys.stderr)
        sys.exit(1)

